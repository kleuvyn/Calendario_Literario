{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///home/kleuvyn/Documentos/MeusRepositorios/Calendario_Literario/lib/db.ts"],"sourcesContent":["import { Pool } from 'pg';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL || process.env.POSTGRES_URL,\n  ssl: {\n    rejectUnauthorized: false \n  }\n});\n\nexport async function executeQuery(query: string, params: any[] = []) {\n  try {\n\n    await pool.query('ALTER TABLE users ADD COLUMN IF NOT EXISTS password TEXT;');\n    await pool.query('ALTER TABLE users ADD COLUMN IF NOT EXISTS image TEXT;');\n    await pool.query('ALTER TABLE reading_data ADD COLUMN IF NOT EXISTS author TEXT;');\n    await pool.query('ALTER TABLE reading_data ADD COLUMN IF NOT EXISTS rating INTEGER;');\n    await pool.query('ALTER TABLE reading_data ADD COLUMN IF NOT EXISTS cover_url TEXT;');\n    await pool.query('ALTER TABLE reading_data ADD COLUMN IF NOT EXISTS email TEXT;');\n\n    const result = await pool.query(query, params);\n    return result.rows; \n  } catch (error) {\n    console.error('Erro detalhado no Banco de Dados:', error);\n    throw error;\n  }\n}"],"names":[],"mappings":";;;;AAAA;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY,IAAI,QAAQ,GAAG,CAAC,YAAY;IACtE,KAAK;QACH,oBAAoB;IACtB;AACF;AAEO,eAAe,aAAa,KAAa,EAAE,SAAgB,EAAE;IAClE,IAAI;QAEF,MAAM,KAAK,KAAK,CAAC;QACjB,MAAM,KAAK,KAAK,CAAC;QACjB,MAAM,KAAK,KAAK,CAAC;QACjB,MAAM,KAAK,KAAK,CAAC;QACjB,MAAM,KAAK,KAAK,CAAC;QACjB,MAAM,KAAK,KAAK,CAAC;QAEjB,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,OAAO;QACvC,OAAO,OAAO,IAAI;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC;QACnD,MAAM;IACR;AACF"}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///home/kleuvyn/Documentos/MeusRepositorios/Calendario_Literario/app/api/auth/%5B...nextauth%5D/route.tsx"],"sourcesContent":["import NextAuth from \"next-auth\"\nimport GoogleProvider from \"next-auth/providers/google\"\nimport CredentialsProvider from \"next-auth/providers/credentials\"\nimport { executeQuery } from \"@/lib/db\"\nimport bcrypt from \"bcrypt\"\nimport type { NextAuthOptions } from \"next-auth\"\n\nexport const authOptions: NextAuthOptions = {\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      authorization: { params: { prompt: \"select_account\" } },\n      allowDangerousEmailAccountLinking: true, \n    }),\n    CredentialsProvider({\n      name: \"Credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"text\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) return null\n        \n        const users = await executeQuery(\n          \"SELECT * FROM users WHERE email = $1\", \n          [credentials.email]\n        ) as any[]\n\n        const user = users[0]\n        if (user && user.password && await bcrypt.compare(credentials.password, user.password)) {\n          return { \n            id: user.id.toString(), \n            name: user.name, \n            email: user.email,\n            image: user.image \n          }\n        }\n        return null \n      }\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user, trigger, session }) {\n      if (user) {\n        token.id = user.id;\n        token.picture = (user as any).image; \n      }\n      \n      if (trigger === \"update\" && session?.image) {\n        token.picture = session.image;\n      }\n      \n      return token\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        (session.user as any).id = token.id;\n        session.user.image = token.picture as string; \n      }\n      return session\n    },\n    \n    async signIn({ user, account }) {\n      if (account?.provider === \"google\") {\n        await executeQuery(\n          `INSERT INTO users (name, email, image) \n           VALUES ($1, $2, $3) \n           ON CONFLICT (email) DO UPDATE SET name = $1`, \n          [user.name, user.email, user.image]\n        );\n      }\n      return true;\n    }\n  },\n  session: { strategy: \"jwt\" },\n  secret: process.env.NEXTAUTH_SECRET,\n  pages: { signIn: '/' }\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAGO,MAAM,cAA+B;IAC1C,WAAW;QACT,IAAA,gKAAc,EAAC;YACb,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;YAC9C,eAAe;gBAAE,QAAQ;oBAAE,QAAQ;gBAAiB;YAAE;YACtD,mCAAmC;QACrC;QACA,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAO;gBACtC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU,OAAO;gBAE1D,MAAM,QAAQ,MAAM,IAAA,2HAAY,EAC9B,wCACA;oBAAC,YAAY,KAAK;iBAAC;gBAGrB,MAAM,OAAO,KAAK,CAAC,EAAE;gBACrB,IAAI,QAAQ,KAAK,QAAQ,IAAI,MAAM,gHAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ,GAAG;oBACtF,OAAO;wBACL,IAAI,KAAK,EAAE,CAAC,QAAQ;wBACpB,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;wBACjB,OAAO,KAAK,KAAK;oBACnB;gBACF;gBACA,OAAO;YACT;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACzC,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,OAAO,GAAG,AAAC,KAAa,KAAK;YACrC;YAEA,IAAI,YAAY,YAAY,SAAS,OAAO;gBAC1C,MAAM,OAAO,GAAG,QAAQ,KAAK;YAC/B;YAEA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBACf,QAAQ,IAAI,CAAS,EAAE,GAAG,MAAM,EAAE;gBACnC,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,OAAO;YACpC;YACA,OAAO;QACT;QAEA,MAAM,QAAO,EAAE,IAAI,EAAE,OAAO,EAAE;YAC5B,IAAI,SAAS,aAAa,UAAU;gBAClC,MAAM,IAAA,2HAAY,EAChB,CAAC;;sDAE2C,CAAC,EAC7C;oBAAC,KAAK,IAAI;oBAAE,KAAK,KAAK;oBAAE,KAAK,KAAK;iBAAC;YAEvC;YACA,OAAO;QACT;IACF;IACA,SAAS;QAAE,UAAU;IAAM;IAC3B,QAAQ,QAAQ,GAAG,CAAC,eAAe;IACnC,OAAO;QAAE,QAAQ;IAAI;AACvB;AAEA,MAAM,UAAU,IAAA,kJAAQ,EAAC"}}]
}